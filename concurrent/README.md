20180810
@author cj

这里总结各个高级多线程工具的作用和与应用场景,便于回忆和选用.

1.闭锁 CountDownLatch:
    作用:一条线程A调用await()进入阻塞,等其他线程都调用闭锁的countDown()把闭锁内的计数器清零后,该线程A醒来继续执行.
     * API:
     *  countDownLatch.await() - 阻塞当前线程,直到countDownLatch中的闭锁计数器清零后才会醒来.
     *  countDownLatch.countDown() - 把闭锁的计数器减一.

     所有的类似于主线程需要等待所有子线程处理完数据全都返回后,才能聚拢数据继续处理的场景,都可以用.

     重点: 闭锁内维护了一个计数器,被await()阻塞的线程,只有等到其他线程把计数器通过countDown()清零后,前者才能解除阻塞.


2.ExecutorCompletionService:
     作用:一条线程A调用take()进入阻塞,等每个其他线分别调用ExecutorCompletionService的submit()返回结果后,该线程A每次都会醒来继续执行.
     * API:
     *  submit() - 提交任务
     *  take() - 获取任务结果
     *  poll() - 获取任务结果

     作用于上面的闭锁极为类似! 只是阻塞和唤醒的方式不同.
     每个线程调用submit() - 提交任务然后返回后,被阻塞的主线程都会分别醒来一次来处理本次子线程返回的数据(一般是聚拢放入集合).
     而不是所有子线程都处理完后主线程才会醒来. 所以需要把主线程放入循环中.

     注意: 该方式最后一定要手动关闭线程池!!!


3.信号量 TestSemaphore:
      作用:维护了一组许可证. 可用来做池子.例如线程池或DB连接池.提供阻塞的方法. 池子! 池子!! 池子!!!
            也可以用 BlockingQueue 达到同样的效果.
      * API:
      * semaphore.acquire() - 从信号量中获取一个许可,如果许可证已经为空了,拿不到了,则本线程阻塞! 直到有富裕的许可证可以被拿到.
      * semaphore.release() - 释放一个许可证返回给信号量.


4.栅栏 CyclicBarrier ******(推荐):

    作用:让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。
     *      可以把这个屏障点想象成:每个子线程处理完业务后,而不是处理业务前. 这样就达到了闭锁或CompletionService的效果! 并且不用循环主线程来聚拢数据!
     * API:
     *  await() - 阻塞当前线程,直到所有线程(构造器指定数量)都达到屏障点后,所有被该点阻塞的线程会一起醒来.

     可以把这个看作是闭锁CountDownLatch和CompleteService的优化版本!
     由于闭锁要维护一个计数器,而CompleteService又要循环主线程来聚拢数据,所以,可以用栅栏来避免这两种不便利的情况!! 来做到阻塞等其他线程完成后来聚拢数据!!







